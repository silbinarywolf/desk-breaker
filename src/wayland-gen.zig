//! Generated by zig-wayland, modified/shortened by Jae manually

const std = @import("std");
const assert = std.debug.assert;
const posix = std.posix;

pub const client = struct {
    pub const wl = struct {
        pub const Object = common.Object;
        pub const Message = common.Message;
        pub const Interface = common.Interface;
        pub const list = common.list;
        pub const Array = common.Array;
        pub const Fixed = common.Fixed;
        pub const Argument = common.Argument;

        pub const Proxy = opaque {
            extern fn wl_proxy_create(factory: *Proxy, interface: *const Interface) ?*Proxy;
            pub fn create(factory: *Proxy, interface: *const Interface) error{OutOfMemory}!*Proxy {
                return wl_proxy_create(factory, interface) orelse error.OutOfMemory;
            }

            extern fn wl_proxy_destroy(proxy: *Proxy) void;
            pub const destroy = wl_proxy_destroy;

            extern fn wl_proxy_marshal_array(proxy: *Proxy, opcode: u32, args: ?[*]Argument) void;
            pub const marshal = wl_proxy_marshal_array;

            extern fn wl_proxy_marshal_array_constructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) ?*Proxy;
            pub fn marshalConstructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor(proxy, opcode, args, interface) orelse
                    error.OutOfMemory;
            }

            extern fn wl_proxy_marshal_array_constructor_versioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) ?*Proxy;
            pub fn marshalConstructorVersioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor_versioned(proxy, opcode, args, interface, version) orelse
                    error.OutOfMemory;
            }

            const DispatcherFn = fn (
                implementation: ?*const anyopaque,
                proxy: *Proxy,
                opcode: u32,
                message: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int;
            extern fn wl_proxy_add_dispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) c_int;
            pub fn addDispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) void {
                const ret = wl_proxy_add_dispatcher(proxy, dispatcher, implementation, data);
                // Since there is no way to remove listeners, adding a listener to
                // the same proxy twice is always a bug, so assert instead of returning
                // an error.
                assert(ret != -1); // If this fails, a listener was already added
            }

            extern fn wl_proxy_get_user_data(proxy: *Proxy) ?*anyopaque;
            pub const getUserData = wl_proxy_get_user_data;

            extern fn wl_proxy_get_version(proxy: *Proxy) u32;
            pub const getVersion = wl_proxy_get_version;

            extern fn wl_proxy_get_id(proxy: *Proxy) u32;
            pub const getId = wl_proxy_get_id;

            extern fn wl_proxy_set_queue(proxy: *Proxy, queue: *EventQueue) void;
            pub const setQueue = wl_proxy_set_queue;
        };

        pub const EventQueue = opaque {
            extern fn wl_event_queue_destroy(queue: *EventQueue) void;
            pub const destroy = wl_event_queue_destroy;
        };

        /// The core global object.  This is a special singleton object.  It
        /// is used for internal Wayland protocol features.
        pub const Display = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.display.interface;
            pub const Error = common.wl.display.Error;
            pub fn getId(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getId();
            }
            pub fn getVersion(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getVersion();
            }
            pub fn getUserData(_display: *Display) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getUserData();
            }
            pub fn setQueue(_display: *Display, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// The error event is sent out when a fatal (non-recoverable)
                /// error has occurred.  The object_id argument is the object
                /// where the error occurred, most often in response to a request
                /// to that object.  The code identifies the error and is defined
                /// by the object interface.  As such, each interface defines its
                /// own set of error codes.  The message is a brief description
                /// of the error, for (debugging) convenience.
                @"error": struct {
                    object_id: ?*common.Object,
                    code: u32,
                    message: [*:0]const u8,
                },

                /// This event is used internally by the object ID management
                /// logic. When a client deletes an object that it had created,
                /// the server will send this event to acknowledge that it has
                /// seen the delete request. When the client receives this event,
                /// it will know that it can safely reuse the object ID.
                delete_id: struct {
                    id: u32,
                },
            };
            pub inline fn setListener(
                _display: *Display,
                comptime T: type,
                _listener: *const fn (display: *Display, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Display, T).dispatcher, _listener, _mut_data);
            }
            /// The sync request asks the server to emit the 'done' event
            /// on the returned wl_callback object.  Since requests are
            /// handled in-order and events are delivered in-order, this can
            /// be used as a barrier to ensure all previous requests and the
            /// resulting events have been handled.
            ///
            /// The object returned by this request will be destroyed by the
            /// compositor after the callback is fired and as such the client must not
            /// attempt to use it after that point.
            ///
            /// The callback_data passed in the callback is undefined and should be ignored.
            pub fn sync(_display: *Display) !*client.wl.Callback {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Callback.interface));
            }

            /// This request creates a registry object that allows the client
            /// to list and bind the global objects available from the
            /// compositor.
            ///
            /// It should be noted that the server side resources consumed in
            /// response to a get_registry request can only be released when the
            /// client disconnects, not when the client side proxy is destroyed.
            /// Therefore, clients should invoke get_registry as infrequently as
            /// possible to avoid wasting memory.
            pub fn getRegistry(_display: *Display) !*client.wl.Registry {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Registry.interface));
            }
            extern fn wl_display_connect(name: ?[*:0]const u8) ?*Display;
            pub inline fn connect(name: ?[*:0]const u8) error{ConnectFailed}!*Display {
                return wl_display_connect(name) orelse return error.ConnectFailed;
            }

            extern fn wl_display_connect_to_fd(fd: c_int) ?*Display;
            pub inline fn connectToFd(fd: c_int) error{ConnectFailed}!*Display {
                return wl_display_connect_to_fd(fd) orelse return error.ConnectFailed;
            }

            extern fn wl_display_disconnect(display: *Display) void;
            pub const disconnect = wl_display_disconnect;

            extern fn wl_display_get_fd(display: *Display) c_int;
            pub const getFd = wl_display_get_fd;

            extern fn wl_display_dispatch(display: *Display) c_int;
            pub inline fn dispatch(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch(display));
            }

            extern fn wl_display_dispatch_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue(display, queue));
            }

            extern fn wl_display_dispatch_pending(display: *Display) c_int;
            pub inline fn dispatchPending(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch_pending(display));
            }

            extern fn wl_display_dispatch_queue_pending(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueuePending(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue_pending(display, queue));
            }

            extern fn wl_display_roundtrip(display: *Display) c_int;
            pub inline fn roundtrip(display: *Display) posix.E {
                return posix.errno(wl_display_roundtrip(display));
            }

            extern fn wl_display_roundtrip_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn roundtripQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_roundtrip_queue(display, queue));
            }

            extern fn wl_display_flush(display: *Display) c_int;
            pub inline fn flush(display: *Display) posix.E {
                return posix.errno(wl_display_flush(display));
            }

            extern fn wl_display_create_queue(display: *Display) ?*client.wl.EventQueue;
            pub inline fn createQueue(display: *Display) error{OutOfMemory}!*client.wl.EventQueue {
                return wl_display_create_queue(display) orelse error.OutOfMemory;
            }

            extern fn wl_display_get_error(display: *Display) c_int;
            pub const getError = wl_display_get_error;

            extern fn wl_display_prepare_read_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareReadQueue(display: *Display, queue: *client.wl.EventQueue) bool {
                switch (wl_display_prepare_read_queue(display, queue)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_prepare_read(display: *Display) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareRead(display: *Display) bool {
                switch (wl_display_prepare_read(display)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_cancel_read(display: *Display) void;
            pub const cancelRead = wl_display_cancel_read;

            extern fn wl_display_read_events(display: *Display) c_int;
            pub inline fn readEvents(display: *Display) posix.E {
                return posix.errno(wl_display_read_events(display));
            }
        };

        /// The singleton global registry object.  The server has a number of
        /// global objects that are available to all clients.  These objects
        /// typically represent an actual object in the server (for example,
        /// an input device) or they are singleton objects that provide
        /// extension functionality.
        ///
        /// When a client creates a registry object, the registry object
        /// will emit a global event for each global currently in the
        /// registry.  Globals come and go as a result of device or
        /// monitor hotplugs, reconfiguration or other events, and the
        /// registry will send out global and global_remove events to
        /// keep the client up to date with the changes.  To mark the end
        /// of the initial burst of events, the client can use the
        /// wl_display.sync request immediately after calling
        /// wl_display.get_registry.
        ///
        /// A client can bind to a global object by using the bind
        /// request.  This creates a client-side handle that lets the object
        /// emit events to the client and lets the client invoke requests on
        /// the object.
        pub const Registry = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.registry.interface;
            pub fn getId(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getId();
            }
            pub fn getVersion(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getVersion();
            }
            pub fn getUserData(_registry: *Registry) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getUserData();
            }
            pub fn setQueue(_registry: *Registry, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client of global objects.
                ///
                /// The event notifies the client that a global object with
                /// the given name is now available, and it implements the
                /// given version of the given interface.
                global: struct {
                    name: u32,
                    interface: [*:0]const u8,
                    version: u32,
                },

                /// Notify the client of removed global objects.
                ///
                /// This event notifies the client that the global identified
                /// by name is no longer available.  If the client bound to
                /// the global using the bind request, the client should now
                /// destroy that object.
                ///
                /// The object remains valid and requests to the object will be
                /// ignored until the client destroys it, to avoid races between
                /// the global going away and a client sending a request to it.
                global_remove: struct {
                    name: u32,
                },
            };
            pub inline fn setListener(
                _registry: *Registry,
                comptime T: type,
                _listener: *const fn (registry: *Registry, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Registry, T).dispatcher, _listener, _mut_data);
            }
            /// Binds a new, client-created object to the server using the
            /// specified name as the identifier.
            pub fn bind(_registry: *Registry, _name: u32, comptime T: type, _version: u32) !*T {
                const version_to_construct = @min(T.generated_version, _version);
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                    .{ .s = T.interface.name },
                    .{ .u = version_to_construct },
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructorVersioned(0, &_args, T.interface, version_to_construct));
            }
            pub fn destroy(_registry: *Registry) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.destroy();
            }
        };

        /// Clients can handle the 'done' event to get notified when
        /// the related request is done.
        ///
        /// Note, because wl_callback objects are created from multiple independent
        /// factory interfaces, the wl_callback interface is frozen at version 1.
        pub const Callback = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.callback.interface;
            pub fn getId(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getId();
            }
            pub fn getVersion(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getVersion();
            }
            pub fn getUserData(_callback: *Callback) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getUserData();
            }
            pub fn setQueue(_callback: *Callback, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client when the related request is done.
                done: struct {
                    callback_data: u32,
                },
            };
            pub inline fn setListener(
                _callback: *Callback,
                comptime T: type,
                _listener: *const fn (callback: *Callback, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Callback, T).dispatcher, _listener, _mut_data);
            }
            pub fn destroy(_callback: *Callback) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.destroy();
            }
        };

        /// A buffer provides the content for a wl_surface. Buffers are
        /// created through factory interfaces such as wl_shm, wp_linux_buffer_params
        /// (from the linux-dmabuf protocol extension) or similar. It has a width and
        /// a height and can be attached to a wl_surface, but the mechanism by which a
        /// client provides and updates the contents is defined by the buffer factory
        /// interface.
        ///
        /// Color channels are assumed to be electrical rather than optical (in other
        /// words, encoded with a transfer function) unless otherwise specified. If
        /// the buffer uses a format that has an alpha channel, the alpha channel is
        /// assumed to be premultiplied into the electrical color channel values
        /// (after transfer function encoding) unless otherwise specified.
        ///
        /// Note, because wl_buffer objects are created from multiple independent
        /// factory interfaces, the wl_buffer interface is frozen at version 1.
        pub const Buffer = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.buffer.interface;
            pub fn getId(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getId();
            }
            pub fn getVersion(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getVersion();
            }
            pub fn getUserData(_buffer: *Buffer) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getUserData();
            }
            pub fn setQueue(_buffer: *Buffer, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Sent when this wl_buffer is no longer used by the compositor.
                ///
                /// For more information on when release events may or may not be sent,
                /// and what consequences it has, please see the description of
                /// wl_surface.attach.
                ///
                /// If a client receives a release event before the frame callback
                /// requested in the same wl_surface.commit that attaches this
                /// wl_buffer to a surface, then the client is immediately free to
                /// reuse the buffer and its backing storage, and does not need a
                /// second buffer for the next surface content update. Typically
                /// this is possible, when the compositor maintains a copy of the
                /// wl_surface contents, e.g. as a GL texture. This is an important
                /// optimization for GL(ES) compositors with wl_shm clients.
                release: void,
            };
            pub inline fn setListener(
                _buffer: *Buffer,
                comptime T: type,
                _listener: *const fn (buffer: *Buffer, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Buffer, T).dispatcher, _listener, _mut_data);
            }
            /// Destroy a buffer. If and how you need to release the backing
            /// storage is defined by the buffer factory interface.
            ///
            /// For possible side-effects to a surface, see wl_surface.attach.
            pub fn destroy(_buffer: *Buffer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
        };

        /// A seat is a group of keyboards, pointer and touch devices. This
        /// object is published as a global during start up, or when such a
        /// device is hot plugged.  A seat typically has a pointer and
        /// maintains a keyboard focus and a pointer focus.
        pub const Seat = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.seat.interface;
            pub const Capability = common.wl.seat.Capability;
            pub const Error = common.wl.seat.Error;
            pub fn getId(_seat: *Seat) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getId();
            }
            pub fn getVersion(_seat: *Seat) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getVersion();
            }
            pub fn getUserData(_seat: *Seat) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getUserData();
            }
            pub fn setQueue(_seat: *Seat, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This is sent on binding to the seat global or whenever a seat gains
                /// or loses the pointer, keyboard or touch capabilities.
                /// The argument is a capability enum containing the complete set of
                /// capabilities this seat has.
                ///
                /// When the pointer capability is added, a client may create a
                /// wl_pointer object using the wl_seat.get_pointer request. This object
                /// will receive pointer events until the capability is removed in the
                /// future.
                ///
                /// When the pointer capability is removed, a client should destroy the
                /// wl_pointer objects associated with the seat where the capability was
                /// removed, using the wl_pointer.release request. No further pointer
                /// events will be received on these objects.
                ///
                /// In some compositors, if a seat regains the pointer capability and a
                /// client has a previously obtained wl_pointer object of version 4 or
                /// less, that object may start sending pointer events again. This
                /// behavior is considered a misinterpretation of the intended behavior
                /// and must not be relied upon by the client. wl_pointer objects of
                /// version 5 or later must not send events if created before the most
                /// recent event notifying the client of an added pointer capability.
                ///
                /// The above behavior also applies to wl_keyboard and wl_touch with the
                /// keyboard and touch capabilities, respectively.
                capabilities: struct {
                    capabilities: Capability,
                },

                /// In a multi-seat configuration the seat name can be used by clients to
                /// help identify which physical devices the seat represents.
                ///
                /// The seat name is a UTF-8 string with no convention defined for its
                /// contents. Each name is unique among all wl_seat globals. The name is
                /// only guaranteed to be unique for the current compositor instance.
                ///
                /// The same seat names are used for all clients. Thus, the name can be
                /// shared across processes to refer to a specific wl_seat global.
                ///
                /// The name event is sent after binding to the seat global, and should be sent
                /// before announcing capabilities. This event only sent once per seat object,
                /// and the name does not change over the lifetime of the wl_seat global.
                ///
                /// Compositors may re-use the same seat name if the wl_seat global is
                /// destroyed and re-created later.
                name: struct {
                    name: [*:0]const u8,
                },
            };
            pub inline fn setListener(
                _seat: *Seat,
                comptime T: type,
                _listener: *const fn (seat: *Seat, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Seat, T).dispatcher, _listener, _mut_data);
            }
            /// The ID provided will be initialized to the wl_pointer interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the pointer
            /// capability, or has had the pointer capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the pointer capability. The missing_capability error will
            /// be sent in this case.
            pub fn getPointer(_seat: *Seat) !*client.wl.Pointer {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Pointer.interface));
            }

            /// The ID provided will be initialized to the wl_keyboard interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the keyboard
            /// capability, or has had the keyboard capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the keyboard capability. The missing_capability error will
            /// be sent in this case.
            pub fn getKeyboard(_seat: *Seat) !*client.wl.Keyboard {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Keyboard.interface));
            }

            /// The ID provided will be initialized to the wl_touch interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the touch
            /// capability, or has had the touch capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the touch capability. The missing_capability error will
            /// be sent in this case.
            pub fn getTouch(_seat: *Seat) !*client.wl.Touch {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(2, &_args, client.wl.Touch.interface));
            }

            /// Using this request a client can tell the server that it is not going to
            /// use the seat object anymore.
            pub fn release(_seat: *Seat) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.marshal(3, null);
                _proxy.destroy();
            }
            pub fn destroy(_seat: *Seat) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.destroy();
            }
        };

        /// The wl_pointer interface represents one or more input devices,
        /// such as mice, which control the pointer location and pointer_focus
        /// of a seat.
        ///
        /// The wl_pointer interface generates motion, enter and leave
        /// events for the surfaces that the pointer is located over,
        /// and button and axis events for button presses, button releases
        /// and scrolling.
        pub const Pointer = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.pointer.interface;
            pub const Error = common.wl.pointer.Error;
            pub const ButtonState = common.wl.pointer.ButtonState;
            pub const Axis = common.wl.pointer.Axis;
            pub const AxisSource = common.wl.pointer.AxisSource;
            pub const AxisRelativeDirection = common.wl.pointer.AxisRelativeDirection;
            pub fn getId(_pointer: *Pointer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getId();
            }
            pub fn getVersion(_pointer: *Pointer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getVersion();
            }
            pub fn getUserData(_pointer: *Pointer) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getUserData();
            }
            pub fn setQueue(_pointer: *Pointer, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notification that this seat's pointer is focused on a certain
                /// surface.
                ///
                /// When a seat's focus enters a surface, the pointer image
                /// is undefined and a client should respond to this event by setting
                /// an appropriate pointer image with the set_cursor request.
                enter: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                    surface_x: common.Fixed,
                    surface_y: common.Fixed,
                },

                /// Notification that this seat's pointer is no longer focused on
                /// a certain surface.
                ///
                /// The leave notification is sent before the enter notification
                /// for the new focus.
                leave: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                },

                /// Notification of pointer location change. The arguments
                /// surface_x and surface_y are the location relative to the
                /// focused surface.
                motion: struct {
                    time: u32,
                    surface_x: common.Fixed,
                    surface_y: common.Fixed,
                },

                /// Mouse button click and release notifications.
                ///
                /// The location of the click is given by the last motion or
                /// enter event.
                /// The time argument is a timestamp with millisecond
                /// granularity, with an undefined base.
                ///
                /// The button is a button code as defined in the Linux kernel's
                /// linux/input-event-codes.h header file, e.g. BTN_LEFT.
                ///
                /// Any 16-bit button code value is reserved for future additions to the
                /// kernel's event code list. All other button codes above 0xFFFF are
                /// currently undefined but may be used in future versions of this
                /// protocol.
                button: struct {
                    serial: u32,
                    time: u32,
                    button: u32,
                    state: ButtonState,
                },

                /// Scroll and other axis notifications.
                ///
                /// For scroll events (vertical and horizontal scroll axes), the
                /// value parameter is the length of a vector along the specified
                /// axis in a coordinate space identical to those of motion events,
                /// representing a relative movement along the specified axis.
                ///
                /// For devices that support movements non-parallel to axes multiple
                /// axis events will be emitted.
                ///
                /// When applicable, for example for touch pads, the server can
                /// choose to emit scroll events where the motion vector is
                /// equivalent to a motion event vector.
                ///
                /// When applicable, a client can transform its content relative to the
                /// scroll distance.
                axis: struct {
                    time: u32,
                    axis: Axis,
                    value: common.Fixed,
                },

                /// Indicates the end of a set of events that logically belong together.
                /// A client is expected to accumulate the data in all events within the
                /// frame before proceeding.
                ///
                /// All wl_pointer events before a wl_pointer.frame event belong
                /// logically together. For example, in a diagonal scroll motion the
                /// compositor will send an optional wl_pointer.axis_source event, two
                /// wl_pointer.axis events (horizontal and vertical) and finally a
                /// wl_pointer.frame event. The client may use this information to
                /// calculate a diagonal vector for scrolling.
                ///
                /// When multiple wl_pointer.axis events occur within the same frame,
                /// the motion vector is the combined motion of all events.
                /// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
                /// the same frame, this indicates that axis movement in one axis has
                /// stopped but continues in the other axis.
                /// When multiple wl_pointer.axis_stop events occur within the same
                /// frame, this indicates that these axes stopped in the same instance.
                ///
                /// A wl_pointer.frame event is sent for every logical event group,
                /// even if the group only contains a single wl_pointer event.
                /// Specifically, a client may get a sequence: motion, frame, button,
                /// frame, axis, frame, axis_stop, frame.
                ///
                /// The wl_pointer.enter and wl_pointer.leave events are logical events
                /// generated by the compositor and not the hardware. These events are
                /// also grouped by a wl_pointer.frame. When a pointer moves from one
                /// surface to another, a compositor should group the
                /// wl_pointer.leave event within the same wl_pointer.frame.
                /// However, a client must not rely on wl_pointer.leave and
                /// wl_pointer.enter being in the same wl_pointer.frame.
                /// Compositor-specific policies may require the wl_pointer.leave and
                /// wl_pointer.enter event being split across multiple wl_pointer.frame
                /// groups.
                frame: void,
                /// Source information for scroll and other axes.
                ///
                /// This event does not occur on its own. It is sent before a
                /// wl_pointer.frame event and carries the source information for
                /// all events within that frame.
                ///
                /// The source specifies how this event was generated. If the source is
                /// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
                /// sent when the user lifts the finger off the device.
                ///
                /// If the source is wl_pointer.axis_source.wheel,
                /// wl_pointer.axis_source.wheel_tilt or
                /// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
                /// or may not be sent. Whether a compositor sends an axis_stop event
                /// for these sources is hardware-specific and implementation-dependent;
                /// clients must not rely on receiving an axis_stop event for these
                /// scroll sources and should treat scroll sequences from these scroll
                /// sources as unterminated by default.
                ///
                /// This event is optional. If the source is unknown for a particular
                /// axis event sequence, no event is sent.
                /// Only one wl_pointer.axis_source event is permitted per frame.
                ///
                /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
                /// not guaranteed.
                axis_source: struct {
                    axis_source: AxisSource,
                },

                /// Stop notification for scroll and other axes.
                ///
                /// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
                /// is sent to notify a client that the axis sequence has terminated.
                /// This enables the client to implement kinetic scrolling.
                /// See the wl_pointer.axis_source documentation for information on when
                /// this event may be generated.
                ///
                /// Any wl_pointer.axis events with the same axis_source after this
                /// event should be considered as the start of a new axis motion.
                ///
                /// The timestamp is to be interpreted identical to the timestamp in the
                /// wl_pointer.axis event. The timestamp value may be the same as a
                /// preceding wl_pointer.axis event.
                axis_stop: struct {
                    time: u32,
                    axis: Axis,
                },

                /// Discrete step information for scroll and other axes.
                ///
                /// This event carries the axis value of the wl_pointer.axis event in
                /// discrete steps (e.g. mouse wheel clicks).
                ///
                /// This event is deprecated with wl_pointer version 8 - this event is not
                /// sent to clients supporting version 8 or later.
                ///
                /// This event does not occur on its own, it is coupled with a
                /// wl_pointer.axis event that represents this axis value on a
                /// continuous scale. The protocol guarantees that each axis_discrete
                /// event is always followed by exactly one axis event with the same
                /// axis number within the same wl_pointer.frame. Note that the protocol
                /// allows for other events to occur between the axis_discrete and
                /// its coupled axis event, including other axis_discrete or axis
                /// events. A wl_pointer.frame must not contain more than one axis_discrete
                /// event per axis type.
                ///
                /// This event is optional; continuous scrolling devices
                /// like two-finger scrolling on touchpads do not have discrete
                /// steps and do not generate this event.
                ///
                /// The discrete value carries the directional information. e.g. a value
                /// of -2 is two steps towards the negative direction of this axis.
                ///
                /// The axis number is identical to the axis number in the associated
                /// axis event.
                ///
                /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
                /// not guaranteed.
                axis_discrete: struct {
                    axis: Axis,
                    discrete: i32,
                },
            };
            pub inline fn setListener(
                _pointer: *Pointer,
                comptime T: type,
                _listener: *const fn (pointer: *Pointer, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Pointer, T).dispatcher, _listener, _mut_data);
            }
            /// Set the pointer surface, i.e., the surface that contains the
            /// pointer image (cursor). This request gives the surface the role
            /// of a cursor. If the surface already has another role, it raises
            /// a protocol error.
            ///
            /// The cursor actually changes only if the pointer
            /// focus for this device is one of the requesting client's surfaces
            /// or the surface parameter is the current pointer surface. If
            /// there was a previous surface set with this request it is
            /// replaced. If surface is NULL, the pointer image is hidden.
            ///
            /// The parameters hotspot_x and hotspot_y define the position of
            /// the pointer surface relative to the pointer location. Its
            /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
            /// where (x, y) are the coordinates of the pointer location, in
            /// surface-local coordinates.
            ///
            /// On wl_surface.offset requests to the pointer surface, hotspot_x
            /// and hotspot_y are decremented by the x and y parameters
            /// passed to the request. The offset must be applied by
            /// wl_surface.commit as usual.
            ///
            /// The hotspot can also be updated by passing the currently set
            /// pointer surface to this request with new values for hotspot_x
            /// and hotspot_y.
            ///
            /// The input region is ignored for wl_surfaces with the role of
            /// a cursor. When the use as a cursor ends, the wl_surface is
            /// unmapped.
            ///
            /// The serial parameter must match the latest wl_pointer.enter
            /// serial number sent to the client. Otherwise the request will be
            /// ignored.
            pub fn setCursor(_pointer: *Pointer, _serial: u32, _surface: ?*client.wl.Surface, _hotspot_x: i32, _hotspot_y: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                    .{ .i = _hotspot_x },
                    .{ .i = _hotspot_y },
                };
                _proxy.marshal(0, &_args);
            }

            /// Using this request a client can tell the server that it is not going to
            /// use the pointer object anymore.
            ///
            /// This request destroys the pointer proxy object, so clients must not call
            /// wl_pointer_destroy() after using this request.
            pub fn release(_pointer: *Pointer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.marshal(1, null);
                _proxy.destroy();
            }
            pub fn destroy(_pointer: *Pointer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.destroy();
            }
        };

        /// The wl_keyboard interface represents one or more keyboards
        /// associated with a seat.
        ///
        /// Each wl_keyboard has the following logical state:
        ///
        /// - an active surface (possibly null),
        /// - the keys currently logically down,
        /// - the active modifiers,
        /// - the active group.
        ///
        /// By default, the active surface is null, the keys currently logically down
        /// are empty, the active modifiers and the active group are 0.
        pub const Keyboard = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.keyboard.interface;
            pub const KeymapFormat = common.wl.keyboard.KeymapFormat;
            pub const KeyState = common.wl.keyboard.KeyState;
            pub fn getId(_keyboard: *Keyboard) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getId();
            }
            pub fn getVersion(_keyboard: *Keyboard) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getVersion();
            }
            pub fn getUserData(_keyboard: *Keyboard) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getUserData();
            }
            pub fn setQueue(_keyboard: *Keyboard, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This event provides a file descriptor to the client which can be
                /// memory-mapped in read-only mode to provide a keyboard mapping
                /// description.
                ///
                /// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
                /// the recipient, as MAP_SHARED may fail.
                keymap: struct {
                    format: KeymapFormat,
                    fd: i32,
                    size: u32,
                },

                /// Notification that this seat's keyboard focus is on a certain
                /// surface.
                ///
                /// The compositor must send the wl_keyboard.modifiers event after this
                /// event.
                ///
                /// In the wl_keyboard logical state, this event sets the active surface to
                /// the surface argument and the keys currently logically down to the keys
                /// in the keys argument. The compositor must not send this event if the
                /// wl_keyboard already had an active surface immediately before this event.
                ///
                /// Clients should not use the list of pressed keys to emulate key-press
                /// events. The order of keys in the list is unspecified.
                enter: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                    keys: *common.Array,
                },

                /// Notification that this seat's keyboard focus is no longer on
                /// a certain surface.
                ///
                /// The leave notification is sent before the enter notification
                /// for the new focus.
                ///
                /// In the wl_keyboard logical state, this event resets all values to their
                /// defaults. The compositor must not send this event if the active surface
                /// of the wl_keyboard was not equal to the surface argument immediately
                /// before this event.
                leave: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                },

                /// A key was pressed or released.
                /// The time argument is a timestamp with millisecond
                /// granularity, with an undefined base.
                ///
                /// The key is a platform-specific key code that can be interpreted
                /// by feeding it to the keyboard mapping (see the keymap event).
                ///
                /// If this event produces a change in modifiers, then the resulting
                /// wl_keyboard.modifiers event must be sent after this event.
                ///
                /// In the wl_keyboard logical state, this event adds the key to the keys
                /// currently logically down (if the state argument is pressed) or removes
                /// the key from the keys currently logically down (if the state argument is
                /// released). The compositor must not send this event if the wl_keyboard
                /// did not have an active surface immediately before this event. The
                /// compositor must not send this event if state is pressed (resp. released)
                /// and the key was already logically down (resp. was not logically down)
                /// immediately before this event.
                ///
                /// Since version 10, compositors may send key events with the "repeated"
                /// key state when a wl_keyboard.repeat_info event with a rate argument of
                /// 0 has been received. This allows the compositor to take over the
                /// responsibility of key repetition.
                key: struct {
                    serial: u32,
                    time: u32,
                    key: u32,
                    state: KeyState,
                },

                /// Notifies clients that the modifier and/or group state has
                /// changed, and it should update its local state.
                ///
                /// The compositor may send this event without a surface of the client
                /// having keyboard focus, for example to tie modifier information to
                /// pointer focus instead. If a modifier event with pressed modifiers is sent
                /// without a prior enter event, the client can assume the modifier state is
                /// valid until it receives the next wl_keyboard.modifiers event. In order to
                /// reset the modifier state again, the compositor can send a
                /// wl_keyboard.modifiers event with no pressed modifiers.
                ///
                /// In the wl_keyboard logical state, this event updates the modifiers and
                /// group.
                modifiers: struct {
                    serial: u32,
                    mods_depressed: u32,
                    mods_latched: u32,
                    mods_locked: u32,
                    group: u32,
                },

                /// Informs the client about the keyboard's repeat rate and delay.
                ///
                /// This event is sent as soon as the wl_keyboard object has been created,
                /// and is guaranteed to be received by the client before any key press
                /// event.
                ///
                /// Negative values for either rate or delay are illegal. A rate of zero
                /// will disable any repeating (regardless of the value of delay).
                ///
                /// This event can be sent later on as well with a new value if necessary,
                /// so clients should continue listening for the event past the creation
                /// of wl_keyboard.
                repeat_info: struct {
                    rate: i32,
                    delay: i32,
                },
            };
            pub inline fn setListener(
                _keyboard: *Keyboard,
                comptime T: type,
                _listener: *const fn (keyboard: *Keyboard, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Keyboard, T).dispatcher, _listener, _mut_data);
            }
            pub fn release(_keyboard: *Keyboard) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
            pub fn destroy(_keyboard: *Keyboard) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.destroy();
            }
        };

        /// The wl_touch interface represents a touchscreen
        /// associated with a seat.
        ///
        /// Touch interactions can consist of one or more contacts.
        /// For each contact, a series of events is generated, starting
        /// with a down event, followed by zero or more motion events,
        /// and ending with an up event. Events relating to the same
        /// contact point can be identified by the ID of the sequence.
        pub const Touch = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.touch.interface;
            pub fn getId(_touch: *Touch) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getId();
            }
            pub fn getVersion(_touch: *Touch) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getVersion();
            }
            pub fn getUserData(_touch: *Touch) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getUserData();
            }
            pub fn setQueue(_touch: *Touch, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// A new touch point has appeared on the surface. This touch point is
                /// assigned a unique ID. Future events from this touch point reference
                /// this ID. The ID ceases to be valid after a touch up event and may be
                /// reused in the future.
                down: struct {
                    serial: u32,
                    time: u32,
                    surface: ?*client.wl.Surface,
                    id: i32,
                    x: common.Fixed,
                    y: common.Fixed,
                },

                /// The touch point has disappeared. No further events will be sent for
                /// this touch point and the touch point's ID is released and may be
                /// reused in a future touch down event.
                up: struct {
                    serial: u32,
                    time: u32,
                    id: i32,
                },

                /// A touch point has changed coordinates.
                motion: struct {
                    time: u32,
                    id: i32,
                    x: common.Fixed,
                    y: common.Fixed,
                },

                /// Indicates the end of a set of events that logically belong together.
                /// A client is expected to accumulate the data in all events within the
                /// frame before proceeding.
                ///
                /// A wl_touch.frame terminates at least one event but otherwise no
                /// guarantee is provided about the set of events within a frame. A client
                /// must assume that any state not updated in a frame is unchanged from the
                /// previously known state.
                frame: void,
                /// Sent if the compositor decides the touch stream is a global
                /// gesture. No further events are sent to the clients from that
                /// particular gesture. Touch cancellation applies to all touch points
                /// currently active on this client's surface. The client is
                /// responsible for finalizing the touch points, future touch points on
                /// this surface may reuse the touch point ID.
                ///
                /// No frame event is required after the cancel event.
                cancel: void,
            };
            pub inline fn setListener(
                _touch: *Touch,
                comptime T: type,
                _listener: *const fn (touch: *Touch, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Touch, T).dispatcher, _listener, _mut_data);
            }
            pub fn release(_touch: *Touch) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
            pub fn destroy(_touch: *Touch) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.destroy();
            }
        };
    };
    pub const ext = struct {
        /// This interface allows clients to monitor user idle status.
        ///
        /// After binding to this global, clients can create ext_idle_notification_v1
        /// objects to get notified when the user is idle for a given amount of time.
        pub const IdleNotifierV1 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.ext.idle_notifier_v1.interface;
            pub fn getId(_idle_notifier_v1: *IdleNotifierV1) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notifier_v1)).getId();
            }
            pub fn getVersion(_idle_notifier_v1: *IdleNotifierV1) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notifier_v1)).getVersion();
            }
            pub fn getUserData(_idle_notifier_v1: *IdleNotifierV1) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notifier_v1)).getUserData();
            }
            pub fn setQueue(_idle_notifier_v1: *IdleNotifierV1, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notifier_v1);
                _proxy.setQueue(_queue);
            }
            /// Destroy the manager object. All objects created via this interface
            /// remain valid.
            pub fn destroy(_idle_notifier_v1: *IdleNotifierV1) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notifier_v1);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }

            /// Create a new idle notification object.
            ///
            /// The notification object has a minimum timeout duration and is tied to a
            /// seat. The client will be notified if the seat is inactive for at least
            /// the provided timeout. See ext_idle_notification_v1 for more details.
            ///
            /// A zero timeout is valid and means the client wants to be notified as
            /// soon as possible when the seat is inactive.
            pub fn getIdleNotification(_idle_notifier_v1: *IdleNotifierV1, _timeout: u32, _seat: *client.wl.Seat) !*client.ext.IdleNotificationV1 {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notifier_v1);
                var _args = [_]common.Argument{
                    .{ .o = null },
                    .{ .u = _timeout },
                    .{ .o = @ptrCast(_seat) },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.ext.IdleNotificationV1.interface));
            }

            /// Create a new idle notification object to track input from the
            /// user, such as keyboard and mouse movement. Because this object is
            /// meant to track user input alone, it ignores idle inhibitors.
            ///
            /// The notification object has a minimum timeout duration and is tied to a
            /// seat. The client will be notified if the seat is inactive for at least
            /// the provided timeout. See ext_idle_notification_v1 for more details.
            ///
            /// A zero timeout is valid and means the client wants to be notified as
            /// soon as possible when the seat is inactive.
            pub fn getInputIdleNotification(_idle_notifier_v1: *IdleNotifierV1, _timeout: u32, _seat: *client.wl.Seat) !*client.ext.IdleNotificationV1 {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notifier_v1);
                var _args = [_]common.Argument{
                    .{ .o = null },
                    .{ .u = _timeout },
                    .{ .o = @ptrCast(_seat) },
                };
                return @ptrCast(try _proxy.marshalConstructor(2, &_args, client.ext.IdleNotificationV1.interface));
            }
        };

        /// This interface is used by the compositor to send idle notification events
        /// to clients.
        ///
        /// Initially the notification object is not idle. The notification object
        /// becomes idle when no user activity has happened for at least the timeout
        /// duration, starting from the creation of the notification object. User
        /// activity may include input events or a presence sensor, but is
        /// compositor-specific.
        ///
        /// How this notification responds to idle inhibitors depends on how
        /// it was constructed. If constructed from the
        /// get_idle_notification request, then if an idle inhibitor is
        /// active (e.g. another client has created a zwp_idle_inhibitor_v1
        /// on a visible surface), the compositor must not make the
        /// notification object idle. However, if constructed from the
        /// get_input_idle_notification request, then idle inhibitors are
        /// ignored, and only input from the user, e.g. from a keyboard or
        /// mouse, counts as activity.
        ///
        /// When the notification object becomes idle, an idled event is sent. When
        /// user activity starts again, the notification object stops being idle,
        /// a resumed event is sent and the timeout is restarted.
        pub const IdleNotificationV1 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.ext.idle_notification_v1.interface;
            pub fn getId(_idle_notification_v1: *IdleNotificationV1) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notification_v1)).getId();
            }
            pub fn getVersion(_idle_notification_v1: *IdleNotificationV1) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notification_v1)).getVersion();
            }
            pub fn getUserData(_idle_notification_v1: *IdleNotificationV1) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_idle_notification_v1)).getUserData();
            }
            pub fn setQueue(_idle_notification_v1: *IdleNotificationV1, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notification_v1);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This event is sent when the notification object becomes idle.
                ///
                /// It's a compositor protocol error to send this event twice without a
                /// resumed event in-between.
                idled: void,
                /// This event is sent when the notification object stops being idle.
                ///
                /// It's a compositor protocol error to send this event twice without an
                /// idled event in-between. It's a compositor protocol error to send this
                /// event prior to any idled event.
                resumed: void,
            };
            pub inline fn setListener(
                _idle_notification_v1: *IdleNotificationV1,
                comptime T: type,
                _listener: *const fn (idle_notification_v1: *IdleNotificationV1, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notification_v1);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(IdleNotificationV1, T).dispatcher, _listener, _mut_data);
            }
            /// Destroy the notification object.
            pub fn destroy(_idle_notification_v1: *IdleNotificationV1) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_idle_notification_v1);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
        };
    };
};

const common = struct {
    const Object = opaque {};

    const Message = extern struct {
        name: [*:0]const u8,
        signature: [*:0]const u8,
        types: ?[*]const ?*const Interface,
    };

    const Interface = extern struct {
        name: [*:0]const u8,
        version: c_int,
        method_count: c_int,
        methods: ?[*]const Message,
        event_count: c_int,
        events: ?[*]const Message,
    };

    const Array = extern struct {
        size: usize,
        alloc: usize,
        data: ?*anyopaque,

        /// Does not clone memory
        pub fn fromArrayList(comptime T: type, array_list: std.ArrayList(T)) Array {
            return Array{
                .size = array_list.items.len * @sizeOf(T),
                .alloc = array_list.capacity * @sizeOf(T),
                .data = array_list.items.ptr,
            };
        }

        pub fn slice(array: Array, comptime T: type) []align(4) T {
            const data = array.data orelse return &[0]T{};
            // The wire protocol/libwayland only guarantee 32-bit word alignment.
            const ptr: [*]align(4) T = @ptrCast(@alignCast(data));
            return ptr[0..@divExact(array.size, @sizeOf(T))];
        }
    };

    /// A 24.8 signed fixed-point number.
    const Fixed = enum(i32) {
        _,

        pub fn toInt(f: Fixed) i24 {
            return @truncate(@intFromEnum(f) >> 8);
        }

        pub fn fromInt(i: i24) Fixed {
            return @enumFromInt(@as(i32, i) << 8);
        }

        pub fn toDouble(f: Fixed) f64 {
            return @as(f64, @floatFromInt(@intFromEnum(f))) / 256;
        }

        pub fn fromDouble(d: f64) Fixed {
            return @enumFromInt(@as(i32, @intFromFloat(d * 256)));
        }
    };

    const Argument = extern union {
        i: i32,
        u: u32,
        f: Fixed,
        s: ?[*:0]const u8,
        o: ?*Object,
        n: u32,
        a: ?*Array,
        h: i32,
    };

    fn Dispatcher(comptime Obj: type, comptime Data: type) type {
        const client_side = @hasDecl(Obj, "Event");
        const Payload = if (client_side) Obj.Event else Obj.Request;
        return struct {
            fn dispatcher(
                implementation: ?*const anyopaque,
                object: if (client_side) *client.wl.Proxy else @compileError("only client is supported"),
                opcode: u32,
                _: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int {
                inline for (@typeInfo(Payload).@"union".fields, 0..) |payload_field, payload_num| {
                    if (payload_num == opcode) {
                        var payload_data: payload_field.type = undefined;
                        if (payload_field.type != void) {
                            inline for (@typeInfo(payload_field.type).@"struct".fields, 0..) |f, i| {
                                switch (@typeInfo(f.type)) {
                                    // signed/unsigned ints, fds, new_ids, bitfield enums
                                    .int, .@"struct" => @field(payload_data, f.name) = @as(f.type, @bitCast(args[i].u)),
                                    // objects, strings, arrays
                                    .pointer, .optional => @field(payload_data, f.name) = @as(f.type, @ptrFromInt(@intFromPtr(args[i].o))),
                                    // non-bitfield enums
                                    .@"enum" => @field(payload_data, f.name) = @as(f.type, @enumFromInt(args[i].i)),
                                    else => unreachable,
                                }
                            }
                        }

                        const HandlerFn = fn (*Obj, Payload, Data) void;
                        @as(*const HandlerFn, @ptrCast(@alignCast(implementation)))(
                            @as(*Obj, @ptrCast(object)),
                            @unionInit(Payload, payload_field.name, payload_data),
                            @as(Data, @ptrFromInt(@intFromPtr(object.getUserData()))),
                        );

                        return 0;
                    }
                }
                unreachable;
            }
        };
    }
    const wl = struct {
        const display = struct {
            const interface: common.Interface = .{
                .name = "wl_display",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "sync",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "get_registry",
                        .signature = "n",
                        .types = &.{
                            &common.wl.registry.interface,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "error",
                        .signature = "ous",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "delete_id",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// These errors are global and can be emitted in response to any
            /// server request.
            const Error = enum(c_int) {
                invalid_object = 0,
                invalid_method = 1,
                no_memory = 2,
                implementation = 3,
                _,
            };
        };
        const registry = struct {
            const interface: common.Interface = .{
                .name = "wl_registry",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "bind",
                        .signature = "usun",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "global",
                        .signature = "usu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "global_remove",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const callback = struct {
            const interface: common.Interface = .{
                .name = "wl_callback",
                .version = 1,
                .method_count = 0,
                .methods = null,
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "done",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const buffer = struct {
            const interface: common.Interface = .{
                .name = "wl_buffer",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "release",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
        const surface = struct {
            const interface: common.Interface = .{
                .name = "wl_surface",
                .version = 6,
                .method_count = 11,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "attach",
                        .signature = "?oii",
                        .types = &.{
                            &common.wl.buffer.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "damage",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "set_opaque_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "set_input_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "commit",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_buffer_transform",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "set_buffer_scale",
                        .signature = "3i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "damage_buffer",
                        .signature = "4iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "offset",
                        .signature = "5ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 4,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "preferred_buffer_scale",
                        .signature = "6i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "preferred_buffer_transform",
                        .signature = "6u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const region = struct {
            const interface: common.Interface = .{
                .name = "wl_region",
                .version = 1,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "add",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "subtract",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const seat = struct {
            const interface: common.Interface = .{
                .name = "wl_seat",
                .version = 10,
                .method_count = 4,
                .methods = &.{
                    .{
                        .name = "get_pointer",
                        .signature = "n",
                        .types = &.{
                            &common.wl.pointer.interface,
                        },
                    },
                    .{
                        .name = "get_keyboard",
                        .signature = "n",
                        .types = &.{
                            &common.wl.keyboard.interface,
                        },
                    },
                    .{
                        .name = "get_touch",
                        .signature = "n",
                        .types = &.{
                            &common.wl.touch.interface,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "5",
                        .types = null,
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "capabilities",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "2s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// This is a bitmask of capabilities this seat has; if a member is
            /// set, then it is present on the seat.
            const Capability = packed struct(u32) {
                pointer: bool = false,
                keyboard: bool = false,
                touch: bool = false,
                _padding3: bool = false,
                _padding4: bool = false,
                _padding5: bool = false,
                _padding6: bool = false,
                _padding7: bool = false,
                _padding8: bool = false,
                _padding9: bool = false,
                _padding10: bool = false,
                _padding11: bool = false,
                _padding12: bool = false,
                _padding13: bool = false,
                _padding14: bool = false,
                _padding15: bool = false,
                _padding16: bool = false,
                _padding17: bool = false,
                _padding18: bool = false,
                _padding19: bool = false,
                _padding20: bool = false,
                _padding21: bool = false,
                _padding22: bool = false,
                _padding23: bool = false,
                _padding24: bool = false,
                _padding25: bool = false,
                _padding26: bool = false,
                _padding27: bool = false,
                _padding28: bool = false,
                _padding29: bool = false,
                _padding30: bool = false,
                _padding31: bool = false,
                pub const Enum = enum(c_int) {
                    pointer = 1,
                    keyboard = 2,
                    touch = 4,
                    _,
                };
            };

            /// These errors can be emitted in response to wl_seat requests.
            const Error = enum(c_int) {
                missing_capability = 0,
                _,
            };
        };
        const pointer = struct {
            const interface: common.Interface = .{
                .name = "wl_pointer",
                .version = 10,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "set_cursor",
                        .signature = "u?oii",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 11,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "uoff",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "button",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis",
                        .signature = "uuf",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "5",
                        .types = null,
                    },
                    .{
                        .name = "axis_source",
                        .signature = "5u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "axis_stop",
                        .signature = "5uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_discrete",
                        .signature = "5ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_value120",
                        .signature = "8ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_relative_direction",
                        .signature = "9uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
            const Error = enum(c_int) {
                role = 0,
                _,
            };

            /// Describes the physical state of a button that produced the button
            /// event.
            const ButtonState = enum(c_int) {
                released = 0,
                pressed = 1,
                _,
            };

            /// Describes the axis types of scroll events.
            const Axis = enum(c_int) {
                vertical_scroll = 0,
                horizontal_scroll = 1,
                _,
            };

            /// Describes the source types for axis events. This indicates to the
            /// client how an axis event was physically generated; a client may
            /// adjust the user interface accordingly. For example, scroll events
            /// from a "finger" source may be in a smooth coordinate space with
            /// kinetic scrolling whereas a "wheel" source may be in discrete steps
            /// of a number of lines.
            ///
            /// The "continuous" axis source is a device generating events in a
            /// continuous coordinate space, but using something other than a
            /// finger. One example for this source is button-based scrolling where
            /// the vertical motion of a device is converted to scroll events while
            /// a button is held down.
            ///
            /// The "wheel tilt" axis source indicates that the actual device is a
            /// wheel but the scroll event is not caused by a rotation but a
            /// (usually sideways) tilt of the wheel.
            const AxisSource = enum(c_int) {
                wheel = 0,
                finger = 1,
                continuous = 2,
                _,
            };

            /// This specifies the direction of the physical motion that caused a
            /// wl_pointer.axis event, relative to the wl_pointer.axis direction.
            const AxisRelativeDirection = enum(c_int) {
                identical = 0,
                inverted = 1,
                _,
            };
        };
        const keyboard = struct {
            const interface: common.Interface = .{
                .name = "wl_keyboard",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "keymap",
                        .signature = "uhu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "enter",
                        .signature = "uoa",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "key",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "modifiers",
                        .signature = "uuuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "repeat_info",
                        .signature = "4ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
            /// This specifies the format of the keymap provided to the
            /// client with the wl_keyboard.keymap event.
            const KeymapFormat = enum(c_int) {
                no_keymap = 0,
                xkb_v1 = 1,
                _,
            };

            /// Describes the physical state of a key that produced the key event.
            ///
            /// Since version 10, the key can be in a "repeated" pseudo-state which
            /// means the same as "pressed", but is used to signal repetition in the
            /// key event.
            ///
            /// The key may only enter the repeated state after entering the pressed
            /// state and before entering the released state. This event may be
            /// generated multiple times while the key is down.
            const KeyState = enum(c_int) {
                released = 0,
                pressed = 1,
                _,
            };
        };
        const touch = struct {
            const interface: common.Interface = .{
                .name = "wl_touch",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 7,
                .events = &.{
                    .{
                        .name = "down",
                        .signature = "uuoiff",
                        .types = &.{
                            null,
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "up",
                        .signature = "uui",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uiff",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "cancel",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "shape",
                        .signature = "6iff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "orientation",
                        .signature = "6if",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
        };
        const output = struct {
            const interface: common.Interface = .{
                .name = "wl_output",
                .version = 4,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "geometry",
                        .signature = "iiiiissi",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "mode",
                        .signature = "uiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "done",
                        .signature = "2",
                        .types = null,
                    },
                    .{
                        .name = "scale",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "description",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
    };
    const ext = struct {
        const idle_notifier_v1 = struct {
            const interface: common.Interface = .{
                .name = "ext_idle_notifier_v1",
                .version = 2,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "get_idle_notification",
                        .signature = "nuo",
                        .types = &.{
                            &common.ext.idle_notification_v1.interface,
                            null,
                            &common.wl.seat.interface,
                        },
                    },
                    .{
                        .name = "get_input_idle_notification",
                        .signature = "2nuo",
                        .types = &.{
                            &common.ext.idle_notification_v1.interface,
                            null,
                            &common.wl.seat.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const idle_notification_v1 = struct {
            const interface: common.Interface = .{
                .name = "ext_idle_notification_v1",
                .version = 2,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "idled",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "resumed",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
    };
};
