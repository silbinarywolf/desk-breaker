const std = @import("std");
const fs = std.fs;
const ascii = std.ascii;

pub const SDLBuildGenerator = struct {
    arena_allocator: std.heap.ArenaAllocator,
    dir_depth: u32,

    stream: std.io.FixedBufferStream([]u8),
    sdl_dir: []const u8,

    pub fn init(gpa_allocator: std.mem.Allocator, sdl_dir: []const u8) !@This() {
        var arena_allocator = std.heap.ArenaAllocator.init(gpa_allocator);
        errdefer arena_allocator.deinit();
        const allocator = arena_allocator.allocator();

        // Test correct SDL3 directory
        // - src/SDL.c
        try fs.accessAbsolute(try fs.path.join(allocator, &.{ sdl_dir, "src", "SDL.c" }), .{});

        const data = try allocator.alloc(u8, 1_000_000); // Surely shouldn't need more than 1mb
        var stream: std.io.FixedBufferStream([]u8) = std.io.fixedBufferStream(data);

        // setup header
        var writer = stream.writer().any();
        try writer.writeAll(
            \\//! This file is generated by tools/gen_sdlbuild.zig.
        );
        try writer.writeAll("\n");

        return SDLBuildGenerator{
            .arena_allocator = arena_allocator,
            .stream = stream,
            .sdl_dir = sdl_dir,
            .dir_depth = 0,
        };
    }

    pub fn deinit(g: *@This()) void {
        g.arena_allocator.deinit();
        g.* = undefined;
    }

    pub fn generateSDLBuild(g: *@This()) !void {
        const allocator = g.arena_allocator.allocator();
        var dir = try fs.openDirAbsolute(try fs.path.join(allocator, &.{ g.sdl_dir, "src" }), .{ .iterate = true });
        defer dir.close();

        // iterate files
        const writer = g.stream.writer().any();
        try g.readAndWriteModule(writer, dir, "", "src");
    }

    pub fn formatAndWriteFile(g: *@This(), dest_path: []const u8) !void {
        const allocator = g.arena_allocator.allocator();
        const output_unformatted = g.stream.getWritten();

        // Run "zig fmt" over the code
        const output_formatted: []const u8 = blk: {
            // const res = try std.process.Child.run(.{
            //     .allocator = allocator,
            //     .argv = &.{ "zig", "fmt", "--stdin", output_unformatted },
            // });
            var child = std.process.Child.init(&.{ "zig", "fmt", "--stdin", "--ast-check" }, allocator);
            // child.env_map = &b.graph.env_map;
            child.stdin_behavior = .Pipe;
            child.stdout_behavior = .Pipe;
            child.stderr_behavior = .Pipe;

            try child.spawn();

            try child.stdin.?.writeAll(output_unformatted);
            child.stdin.?.close();
            child.stdin = null;

            var poller = std.io.poll(allocator, enum { stdout, stderr }, .{
                .stdout = child.stdout.?,
                .stderr = child.stderr.?,
            });
            defer poller.deinit();

            const max_stdio_size = 10 * 1024 * 1024;
            while (try poller.poll()) {
                if (poller.fifo(.stdout).count > max_stdio_size)
                    return error.StdoutStreamTooLong;
                if (poller.fifo(.stderr).count > max_stdio_size)
                    return error.StderrStreamTooLong;
            }
            const stderr_bytes = try poller.fifo(.stderr).toOwnedSlice();
            if (stderr_bytes.len > 0) {
                std.log.err("zig fmt failed: {s}\n\noutput: {s}", .{ stderr_bytes, output_unformatted });
                return error.ZigFmtError;
            }

            const stdout_bytes = try poller.fifo(.stdout).toOwnedSlice();
            break :blk stdout_bytes;
        };

        var dest_file = try std.fs.createFileAbsolute(dest_path, .{});
        defer dest_file.close();
        try dest_file.writeAll(output_formatted);
    }

    pub fn generateSDLConfig(g: *@This()) !void {
        const allocator = g.arena_allocator.allocator();
        var file = try fs.openFileAbsolute(try std.fs.path.join(allocator, &.{ g.sdl_dir, "include", "build_config", "SDL_build_config.h.cmake" }), .{});
        defer file.close();

        const build_config_data = try file.readToEndAlloc(allocator, 1_000_000); // At time of writing its 23kb
        defer allocator.free(build_config_data);

        var data = build_config_data;

        // Skip past header comments
        const include_byte_index: usize = std.mem.indexOf(u8, data, "#include") orelse {
            return error.UnableToFindInclude;
        };
        data = data[include_byte_index..];
        data = skipToNextLine(data) orelse {
            return error.EOF;
        };

        const Kind = enum {
            none,
            cmakedefine,
            sdlinterpolate,
        };

        var macro_names: std.ArrayListUnmanaged([]const u8) = .{};
        loop: while (true) {
            var found_kind: Kind = .none;
            var maybe_found_i: ?usize = null;
            inline for ([_]Kind{ .cmakedefine, .sdlinterpolate }) |kind| {
                const needle: []const u8 = comptime switch (kind) {
                    .none => unreachable,
                    .cmakedefine => "#cmakedefine",
                    // ie. #if @SDL_DEFAULT_ASSERT_LEVEL_CONFIGURED@
                    // .ifinterpolate => "#if @",
                    .sdlinterpolate => "@SDL_",
                };
                if (std.mem.indexOf(u8, data, needle)) |i| {
                    if (maybe_found_i == null or i < maybe_found_i.?) {
                        found_kind = kind;
                        maybe_found_i = i;
                    }
                }
            }
            if (found_kind == .none) {
                break :loop;
            }
            const found_i = maybe_found_i.?;

            // Skip to found needle
            data = data[found_i..];
            switch (found_kind) {
                .none => unreachable,
                .cmakedefine => {
                    const first_space_index = std.mem.indexOfScalar(u8, data, ' ') orelse {
                        @panic("expected space after #cmakedefine macro");
                    };
                    data = data[first_space_index + 1 ..];
                    if (!ascii.isAlphabetic(data[0])) {
                        @panic("expected alphabetic character after #cmakedefine macro");
                    }
                    const value_space_index = std.mem.indexOfAny(u8, data, &.{ ' ', '\n' }) orelse {
                        @panic("expected whitespace after #cmakedefine identifier (ie. #cmakedefine IDENTIFIER)");
                    };
                    const macro_name = data[0..value_space_index];
                    data = skipToNextLine(data) orelse {
                        @panic("unable to skip to next line");
                    };
                    const has_existing: bool = blk: {
                        for (macro_names.items) |existing_macro_name| {
                            if (std.mem.eql(u8, macro_name, existing_macro_name)) {
                                break :blk true;
                            }
                        }
                        break :blk false;
                    };
                    if (!has_existing) {
                        try macro_names.append(allocator, macro_name);
                    }
                    // std.debug.print("#cmakedefine: macro '{s}' data: {s}\n", .{ macro_name, getTillNextLine(data) });
                },
                .sdlinterpolate => {
                    data = data["@".len..];
                    const closing_at_index = std.mem.indexOfScalar(u8, data, '@') orelse {
                        @panic("expected @ after interpolate if statement");
                    };
                    const macro_name = data[0..closing_at_index];
                    const has_existing: bool = blk: {
                        for (macro_names.items) |existing_macro_name| {
                            if (std.mem.eql(u8, macro_name, existing_macro_name)) {
                                break :blk true;
                            }
                        }
                        break :blk false;
                    };
                    if (!has_existing) {
                        try macro_names.append(allocator, macro_name);
                    }
                    // std.debug.print("#if @: macro '{s}' data: {s}\n", .{ macro_name, getTillNextLine(data) });
                },
            }
        }

        if (macro_names.items.len > 0) {
            const writer = g.stream.writer();
            try writer.writeAll("\npub const SDLConfig = struct {\n");
            for (macro_names.items) |macro_name| {
                if (std.mem.startsWith(u8, macro_name, "HAVE_")) {
                    try writer.print("{s}: bool = false,\n", .{macro_name});
                } else if (std.mem.indexOf(u8, macro_name, "_DYNAMIC") != null) {
                    // Handle linked library names like:
                    // - #define SDL_VIDEO_DRIVER_X11_DYNAMIC "libX11.so.6"
                    // - #define SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR "libXcursor.so.1"
                    try writer.print("{s}: []const u8 = &[0]u8{{}},\n", .{macro_name});
                } else if (std.mem.indexOf(u8, macro_name, "VERSION_MAJOR") != null or
                    std.mem.indexOf(u8, macro_name, "VERSION_MINOR") != null or
                    std.mem.indexOf(u8, macro_name, "VERSION_PATCH") != null)
                {
                    // Handle libdecor
                    // - #define SDL_LIBDECOR_VERSION_MAJOR 0
                    // - #define SDL_LIBDECOR_VERSION_MINOR 2
                    // - #define SDL_LIBDECOR_VERSION_PATCH 2
                    try writer.print("{s}: u32 = 0,\n", .{macro_name});
                } else if (std.mem.eql(u8, macro_name, "SDL_DEFAULT_ASSERT_LEVEL")) {
                    try writer.writeAll("/// SDL internal assertion support, 0 = disabled, 1 = release, 2 = enabled, 3 = paranoid\n");
                    try writer.print("{s}: u4 = 0,\n", .{macro_name});
                } else {
                    // Default to bool
                    try writer.print("{s}: bool = false,\n", .{macro_name});
                }
            }
            try writer.writeAll("};\n\n");
        }
    }

    fn readAndWriteModule(g: *@This(), writer: std.io.AnyWriter, dir: std.fs.Dir, moduleName: []const u8, dirPrefix: []const u8) !void {
        const allocator = g.arena_allocator.allocator();

        var c_files = std.ArrayListUnmanaged([]const u8){};
        var cpp_files = std.ArrayListUnmanaged([]const u8){};
        var objective_c_files = std.ArrayListUnmanaged([]const u8){};
        var win32_resource_files = std.ArrayListUnmanaged([]const u8){};

        //
        const subModuleData = try allocator.alignedAlloc(u8, 16, 250_000); // Surely shouldn't need more than 250kb
        var subModuleStream = std.io.fixedBufferStream(subModuleData);
        const subModulerWriter = subModuleStream.writer().any();

        var it = dir.iterate();
        while (try it.next()) |entry| {
            switch (entry.kind) {
                .file => {
                    const filepath = try std.mem.join(allocator, "/", &.{ dirPrefix, entry.name });
                    if (std.mem.endsWith(u8, entry.name, ".c")) {
                        try c_files.append(allocator, filepath);
                    } else if (std.mem.endsWith(u8, entry.name, ".cpp") or
                        std.mem.endsWith(u8, entry.name, ".cc"))
                    {
                        try cpp_files.append(allocator, filepath);
                    } else if (std.mem.endsWith(u8, entry.name, ".m")) {
                        try objective_c_files.append(allocator, filepath);
                    } else if (std.mem.endsWith(u8, entry.name, ".rc")) {
                        try win32_resource_files.append(allocator, filepath);
                    } else {
                        // Ignore file rules
                        if (std.mem.endsWith(u8, entry.name, ".h") or
                            std.mem.endsWith(u8, entry.name, ".masm") or // Microsoft Macro Assembly, ie. SDL_mslibc_x64.masm
                            std.mem.endsWith(u8, entry.name, ".sym") or // Symbol Table
                            std.mem.endsWith(u8, entry.name, ".m4") or // General purpose macro processor (used in most Unix operating systems)
                            std.mem.eql(u8, entry.name, "LICENSE") or // "LICENSE" ignore license files in folders
                            std.mem.eql(u8, entry.name, "Doxyfile") or // "Doxyfile" is for generating documentation from source code
                            // Mac
                            std.mem.endsWith(u8, entry.name, ".podspec") or // CocoaPods (Mac)
                            std.mem.endsWith(u8, entry.name, ".plist") or // Property list format (MacOS,iOS,iPad)
                            // Code generation code
                            std.mem.endsWith(u8, entry.name, ".py") or // Python
                            std.mem.endsWith(u8, entry.name, ".cs") or // C# (C Sharp)
                            std.mem.endsWith(u8, entry.name, ".pl") or // Perl
                            // Git
                            std.mem.eql(u8, entry.name, ".gitignore") or // .gitignore used for Git
                            std.mem.eql(u8, entry.name, ".gitattributes") or // .gitattributes used for Git
                            // HIDAPI
                            std.mem.eql(u8, entry.name, "VERSION") or // "VERSION" used in hidapi folder, contains something like: "0.14.0"
                            std.mem.endsWith(u8, entry.name, ".pp_data") or // Windows test data for hidapi
                            std.mem.endsWith(u8, entry.name, ".rpt_desc") or // Windows test data for hidapi
                            // Batch / Shell / Config scripts
                            std.mem.endsWith(u8, entry.name, ".bat") or // Windows batch
                            std.mem.endsWith(u8, entry.name, ".sh") or // Shell script
                            std.mem.eql(u8, entry.name, "bootstrap") or // "bootstrap" file with no extension, is a shell script
                            std.mem.endsWith(u8, entry.name, ".ac") or // Automated Configuration
                            std.mem.endsWith(u8, entry.name, ".am") or // Makefile.am programmer defined file
                            std.mem.startsWith(u8, entry.name, "Makefile") or // "Makefile", "Makefile.am", "Makefile.freebsd", "Makefile-manual"
                            std.mem.endsWith(u8, entry.name, ".build") or // Meson.build
                            std.mem.endsWith(u8, entry.name, ".cmake.in") or // Cmake config file input
                            std.mem.endsWith(u8, entry.name, ".pc.in") or // Package config file input
                            std.mem.endsWith(u8, entry.name, ".pc") or // Package config file
                            std.mem.endsWith(u8, entry.name, "-hid.rules") or // Udev file for hidapi
                            // Visual Studio (Windows)
                            std.mem.endsWith(u8, entry.name, ".sln") or // Visual Studio solution file
                            std.mem.endsWith(u8, entry.name, ".vcproj") or // Visual C project
                            std.mem.endsWith(u8, entry.name, ".vcxproj") or // Visual C project (XML)
                            // Shaders
                            std.mem.endsWith(u8, entry.name, ".hlsl") or // High level shader language (DirectX shader file)
                            std.mem.endsWith(u8, entry.name, ".hlsli") or //  High level shader language include (DirectX shader file)
                            std.mem.endsWith(u8, entry.name, ".cg") or // Alias of HLSL, CG = C for Graphics
                            std.mem.endsWith(u8, entry.name, ".metal") or // Metal shader
                            std.mem.endsWith(u8, entry.name, ".frag") or // GL fragment shader
                            std.mem.endsWith(u8, entry.name, ".vert") or // GL vertex shader
                            // Text
                            std.mem.endsWith(u8, entry.name, ".txt") or // Text - AUTHORS.txt
                            std.mem.endsWith(u8, entry.name, ".md") or // Markdow - BUILD.autotools.md
                            // Images
                            std.mem.endsWith(u8, entry.name, ".png") // Portable Network Graphics - cmake-gui-drop-down.png
                        ) {
                            // ignore files we definitely don't want explicitly
                            continue;
                        }
                        std.debug.panic("TODO: Unhandled extension for file: {s}", .{entry.name});
                    }
                },
                .directory => {
                    if (std.mem.eql(u8, entry.name, "test") or // ignore test code
                        std.mem.eql(u8, entry.name, "TestGUI.app.in"))
                    {
                        continue;
                    }
                    const subModuleName = entry.name;
                    var subDir = try dir.openDir(entry.name, .{ .iterate = true });
                    defer subDir.close();
                    const subDirPrefix = try std.mem.join(allocator, "/", &.{ dirPrefix, subModuleName });

                    g.dir_depth += 1;
                    try g.readAndWriteModule(subModulerWriter, subDir, subModuleName, subDirPrefix);
                    g.dir_depth -= 1;
                },
                else => {},
            }
        }

        // If no files, ignore the directory
        const subModulesData = subModuleStream.getWritten();
        if (c_files.items.len == 0 and cpp_files.items.len == 0 and objective_c_files.items.len == 0 and subModulesData.len == 0) {
            return;
        }

        //
        if (moduleName.len > 0) {
            try writer.print("pub const {s} = struct {{\n", .{moduleName});
        }
        if (c_files.items.len > 0) {
            sortStringSliceAlphabetically(c_files.items);
            try writer.writeAll("pub const c_files = [_][]const u8{\n");
            for (c_files.items) |c_file| {
                try writer.print("\"{s}\",\n", .{c_file});
            }
            try writer.writeAll("};\n\n");
        }
        if (cpp_files.items.len > 0) {
            sortStringSliceAlphabetically(cpp_files.items);
            try writer.writeAll("pub const cpp_files = [_][]const u8{\n");
            for (cpp_files.items) |cpp_file| {
                try writer.print("\"{s}\",\n", .{cpp_file});
            }
            try writer.writeAll("};\n\n");
        }
        if (objective_c_files.items.len > 0) {
            sortStringSliceAlphabetically(objective_c_files.items);
            try writer.writeAll("pub const objective_c_files = [_][]const u8{\n");
            for (objective_c_files.items) |objective_c_file| {
                try writer.print("\"{s}\",\n", .{objective_c_file});
            }
            try writer.writeAll("};\n\n");
        }
        if (win32_resource_files.items.len > 0) {
            sortStringSliceAlphabetically(win32_resource_files.items);
            try writer.writeAll("pub const win32_resource_files = [_][]const u8{\n");
            for (win32_resource_files.items) |win32_resource_file| {
                try writer.print("\"{s}\",\n", .{win32_resource_file});
            }
            try writer.writeAll("};\n\n");
        }
        if (subModulesData.len > 0) {
            try writer.writeAll(subModulesData);
        }
        if (moduleName.len > 0) {
            try writer.writeAll("};\n\n");
        }
    }
};

fn stringLessThan(context: void, lhs: []const u8, rhs: []const u8) bool {
    _ = context;
    return std.mem.order(u8, lhs, rhs) == .lt;
}

fn sortStringSliceAlphabetically(slice: [][]const u8) void {
    std.mem.sort([]const u8, slice, {}, stringLessThan);
}

/// Skips to next line or returns null if reached EOF
fn skipToNextLine(data: []u8) ?[]u8 {
    if (std.mem.indexOfScalar(u8, data, '\n')) |i| {
        return data[i + 1 ..];
    }
    return null;
}

/// Used for debug printing the stream
fn getTillNextLine(data: []u8) []u8 {
    if (std.mem.indexOfScalar(u8, data, '\n')) |i| {
        return data[0..i];
    }
    return data;
}
