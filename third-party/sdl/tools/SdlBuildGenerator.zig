const std = @import("std");
const builtin = @import("builtin");
const fs = std.fs;
const ascii = std.ascii;
const Dir = if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
    std.Io.Dir
else
    std.fs.Dir;

b: *std.Build,
arena_allocator: std.heap.ArenaAllocator,
dir_depth: u32,

writer: std.Io.Writer,
sdl_dir: []const u8,

pub fn init(b: *std.Build, sdl_dir: []const u8) !@This() {
    var arena_allocator = std.heap.ArenaAllocator.init(b.allocator);
    errdefer arena_allocator.deinit();
    const allocator = arena_allocator.allocator();

    // Test correct SDL3 directory
    // - src/SDL.c
    if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
        try std.Io.Dir.accessAbsolute(b.graph.io, try fs.path.join(allocator, &.{ sdl_dir, "src", "SDL.c" }), .{})
    else
        try fs.accessAbsolute(try fs.path.join(allocator, &.{ sdl_dir, "src", "SDL.c" }), .{});

    // setup header
    const data = try allocator.alloc(u8, 1_000_000); // Surely shouldn't need more than 1mb
    var writer = std.Io.Writer.fixed(data);
    try writer.writeAll(
        \\//! This file is generated by tools/SdlBuildGenerator.zig.
    );
    try writer.writeAll("\n");

    return SdlBuildGenerator{
        .b = b,
        .arena_allocator = arena_allocator,
        .writer = writer,
        .sdl_dir = sdl_dir,
        .dir_depth = 0,
    };
}

pub fn deinit(g: *@This()) void {
    g.arena_allocator.deinit();
    g.* = undefined;
}

pub fn generateSdlBuild(g: *@This()) !void {
    const allocator = g.arena_allocator.allocator();

    const sdl_src_path = try fs.path.join(allocator, &.{ g.sdl_dir, "src" });
    defer allocator.free(sdl_src_path);

    var dir = if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
        try std.Io.Dir.openDirAbsolute(g.b.graph.io, sdl_src_path, .{ .iterate = true })
    else
        try fs.openDirAbsolute(sdl_src_path, .{ .iterate = true });

    defer if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
        dir.close(g.b.graph.io)
    else
        dir.close();

    // iterate files
    try g.readAndWriteModule(&g.writer, dir, "", "src");
}

pub fn formatAndWriteFile(g: *@This(), dest_path: []const u8) !void {
    if (comptime builtin.zig_version.major == 0 and builtin.zig_version.minor <= 15) {
        // Deprecated path: Zig 0.15.X
        const allocator = g.arena_allocator.allocator();
        const output_unformatted = g.writer.buffered();

        const output_formatted: []const u8 = blk: {
            var child = std.process.Child.init(&.{ "zig", "fmt", "--stdin", "--ast-check" }, allocator);
            child.stdin_behavior = .Pipe;
            child.stdout_behavior = .Pipe;
            child.stderr_behavior = .Pipe;

            try child.spawn();

            try child.stdin.?.writeAll(output_unformatted);
            child.stdin.?.close();
            child.stdin = null;

            const max_output_size = 10 * 1024 * 1024;
            const stdout = child.stdout.?.readToEndAlloc(allocator, max_output_size) catch {
                return error.ReadFailure;
            };
            errdefer allocator.free(stdout);

            const stderr = child.stderr.?.readToEndAlloc(allocator, max_output_size) catch {
                return error.ReadFailure;
            };
            defer allocator.free(stderr);

            const term = try child.wait();
            switch (term) {
                .Exited => |code| {
                    if (code != 0) {
                        std.log.err("zig fmt failed ({}): {s}\n\noutput: {s}", .{ code, stderr, output_unformatted });
                        return error.ZigFmtError;
                    }
                    if (stderr.len > 0) {
                        std.log.err("zig fmt failed ({}): {s}\n\noutput: {s}", .{ code, stderr, output_unformatted });
                        return error.ZigFmtError;
                    }
                    break :blk stdout;
                },
                .Signal, .Stopped, .Unknown => |code| {
                    std.log.err("zig fmt stopped ({}): {s}\n\noutput: {s}", .{ code, stdout, output_unformatted });
                    return error.ZigFmtError;
                },
            }
        };

        var dest_file = try std.fs.createFileAbsolute(dest_path, .{});
        defer dest_file.close();
        try dest_file.writeAll(output_formatted);
        return;
    }

    const allocator = g.arena_allocator.allocator();
    const output_unformatted = g.writer.buffered();
    const io = g.b.graph.io;

    const output_formatted: []const u8 = blk: {
        var child = try std.process.spawn(io, .{
            .argv = &.{ "zig", "fmt", "--stdin", "--ast-check" },
            .stdin = .pipe,
            .stdout = .pipe,
            .stderr = .pipe,
        });
        try child.stdin.?.writeStreamingAll(io, output_unformatted);
        child.stdin.?.close(io);
        child.stdin = null;

        const max_output_size = 10 * 1024 * 1024;
        var stdout_reader = child.stdout.?.readerStreaming(io, &.{});
        const stdout = stdout_reader.interface.allocRemaining(allocator, .limited(max_output_size)) catch {
            return error.ReadFailure;
        };
        errdefer allocator.free(stdout);

        var stderr_reader = child.stdout.?.readerStreaming(io, &.{});
        const stderr = stderr_reader.interface.allocRemaining(allocator, .limited(max_output_size)) catch {
            return error.ReadFailure;
        };
        errdefer allocator.free(stderr);

        const term = try child.wait(io);
        switch (term) {
            .exited => |code| {
                if (code != 0) {
                    std.log.err("zig fmt failed ({}): {s}\n\noutput: {s}", .{ code, stderr, output_unformatted });
                    return error.ZigFmtError;
                }
                if (stderr.len > 0) {
                    std.log.err("zig fmt failed ({}): {s}\n\noutput: {s}", .{ code, stderr, output_unformatted });
                    return error.ZigFmtError;
                }
                break :blk stdout;
            },
            .signal => |sig| {
                std.log.err("zig fmt stopped ({}): {s}\n\noutput: {s}", .{ sig, stdout, output_unformatted });
                return error.ZigFmtError;
            },
            .stopped, .unknown => |code| {
                std.log.err("zig fmt stopped ({}): {s}\n\noutput: {s}", .{ code, stdout, output_unformatted });
                return error.ZigFmtError;
            },
        }
    };

    try std.Io.Dir.cwd().writeFile(io, .{
        .sub_path = dest_path,
        .data = output_formatted,
    });
}

pub fn generateSdlConfig(g: *@This()) !void {
    const allocator = g.arena_allocator.allocator();

    const sdl_build_config_path = try std.fs.path.join(allocator, &.{ g.sdl_dir, "include", "build_config", "SDL_build_config.h.cmake" });
    defer allocator.free(sdl_build_config_path);

    // At time of writing its 23kb
    var data: []u8 = if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
        try std.Io.Dir.cwd().readFileAlloc(g.b.graph.io, sdl_build_config_path, allocator, .unlimited)
    else
        // Deprecated path: Zig 0.15.x
        try fs.cwd().readFileAlloc(allocator, sdl_build_config_path, 1_000_000);

    defer allocator.free(data);

    // Skip past header comments
    const include_byte_index: usize = std.mem.indexOf(u8, data, "#include") orelse {
        return error.UnableToFindInclude;
    };
    data = data[include_byte_index..];
    data = skipToNextLine(data) orelse {
        return error.EOF;
    };

    const Kind = enum {
        none,
        cmakedefine,
        sdlinterpolate,
    };

    var macro_names: std.ArrayListUnmanaged([]const u8) = .{};
    loop: while (true) {
        var found_kind: Kind = .none;
        var maybe_found_i: ?usize = null;
        inline for ([_]Kind{ .cmakedefine, .sdlinterpolate }) |kind| {
            const needle: []const u8 = comptime switch (kind) {
                .none => unreachable,
                .cmakedefine => "#cmakedefine",
                // ie. #if @SDL_DEFAULT_ASSERT_LEVEL_CONFIGURED@
                // .ifinterpolate => "#if @",
                .sdlinterpolate => "@SDL_",
            };
            if (std.mem.indexOf(u8, data, needle)) |i| {
                if (maybe_found_i == null or i < maybe_found_i.?) {
                    found_kind = kind;
                    maybe_found_i = i;
                }
            }
        }
        if (found_kind == .none) {
            break :loop;
        }
        const found_i = maybe_found_i.?;

        // Skip to found needle
        data = data[found_i..];
        switch (found_kind) {
            .none => unreachable,
            .cmakedefine => {
                const first_space_index = std.mem.indexOfScalar(u8, data, ' ') orelse {
                    @panic("expected space after #cmakedefine macro");
                };
                data = data[first_space_index + 1 ..];
                if (!ascii.isAlphabetic(data[0])) {
                    @panic("expected alphabetic character after #cmakedefine macro");
                }
                const value_space_index = std.mem.indexOfAny(u8, data, &.{ ' ', '\n' }) orelse {
                    @panic("expected whitespace after #cmakedefine identifier (ie. #cmakedefine IDENTIFIER)");
                };
                const macro_name = data[0..value_space_index];
                data = skipToNextLine(data) orelse {
                    @panic("unable to skip to next line");
                };
                const has_existing: bool = blk: {
                    for (macro_names.items) |existing_macro_name| {
                        if (std.mem.eql(u8, macro_name, existing_macro_name)) {
                            break :blk true;
                        }
                    }
                    break :blk false;
                };
                if (!has_existing) {
                    try macro_names.append(allocator, macro_name);
                }
                // std.debug.print("#cmakedefine: macro '{s}' data: {s}\n", .{ macro_name, getTillNextLine(data) });
            },
            .sdlinterpolate => {
                data = data["@".len..];
                const closing_at_index = std.mem.indexOfScalar(u8, data, '@') orelse {
                    @panic("expected @ after interpolate if statement");
                };
                const macro_name = data[0..closing_at_index];
                const has_existing: bool = blk: {
                    for (macro_names.items) |existing_macro_name| {
                        if (std.mem.eql(u8, macro_name, existing_macro_name)) {
                            break :blk true;
                        }
                    }
                    break :blk false;
                };
                if (!has_existing) {
                    try macro_names.append(allocator, macro_name);
                }
                // std.debug.print("#if @: macro '{s}' data: {s}\n", .{ macro_name, getTillNextLine(data) });
            },
        }
    }

    if (macro_names.items.len > 0) {
        var writer = &g.writer;
        try writer.writeAll("\npub const SDLConfig = struct {\n");
        for (macro_names.items) |macro_name| {
            if (std.mem.startsWith(u8, macro_name, "HAVE_")) {
                try writer.print("{s}: bool = false,\n", .{macro_name});
            } else if (std.mem.indexOf(u8, macro_name, "_DYNAMIC") != null) {
                // Handle linked library names like:
                // - #define SDL_VIDEO_DRIVER_X11_DYNAMIC "libX11.so.6"
                // - #define SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR "libXcursor.so.1"
                try writer.print("{s}: []const u8 = &[0]u8{{}},\n", .{macro_name});
            } else if (std.mem.indexOf(u8, macro_name, "VERSION_MAJOR") != null or
                std.mem.indexOf(u8, macro_name, "VERSION_MINOR") != null or
                std.mem.indexOf(u8, macro_name, "VERSION_PATCH") != null)
            {
                // Handle libdecor
                // - #define SDL_LIBDECOR_VERSION_MAJOR 0
                // - #define SDL_LIBDECOR_VERSION_MINOR 2
                // - #define SDL_LIBDECOR_VERSION_PATCH 2
                try writer.print("{s}: u32 = 0,\n", .{macro_name});
            } else if (std.mem.eql(u8, macro_name, "SDL_DEFAULT_ASSERT_LEVEL")) {
                try writer.writeAll("/// SDL internal assertion support, 0 = disabled, 1 = release, 2 = enabled, 3 = paranoid\n");
                try writer.print("{s}: u4 = 0,\n", .{macro_name});
            } else {
                // Default to bool
                try writer.print("{s}: bool = false,\n", .{macro_name});
            }
        }
        try writer.writeAll("};\n\n");
    }
}

fn readAndWriteModule(g: *@This(), writer: *std.Io.Writer, dir: Dir, moduleName: []const u8, dirPrefix: []const u8) !void {
    const allocator = g.arena_allocator.allocator();

    var c_files = std.ArrayListUnmanaged([]const u8){};
    var cpp_files = std.ArrayListUnmanaged([]const u8){};
    var objective_c_files = std.ArrayListUnmanaged([]const u8){};
    var win32_resource_files = std.ArrayListUnmanaged([]const u8){};

    //
    const subModuleData = try allocator.alloc(u8, 250_000); // Surely shouldn't need more than 250kb
    var subModulerWriter = std.Io.Writer.fixed(subModuleData);

    var it = dir.iterate();
    while (if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
        try it.next(g.b.graph.io)
    else
        try it.next()) |entry|
    {
        switch (entry.kind) {
            .file => {
                const filepath = try std.mem.join(allocator, "/", &.{ dirPrefix, entry.name });
                if (std.mem.endsWith(u8, entry.name, ".c")) {
                    try c_files.append(allocator, filepath);
                } else if (std.mem.endsWith(u8, entry.name, ".cpp") or
                    std.mem.endsWith(u8, entry.name, ".cc"))
                {
                    try cpp_files.append(allocator, filepath);
                } else if (std.mem.endsWith(u8, entry.name, ".m")) {
                    try objective_c_files.append(allocator, filepath);
                } else if (std.mem.endsWith(u8, entry.name, ".rc")) {
                    try win32_resource_files.append(allocator, filepath);
                } else {
                    // Ignore file rules
                    if (std.mem.endsWith(u8, entry.name, ".h") or
                        std.mem.endsWith(u8, entry.name, ".hpp") or
                        std.mem.endsWith(u8, entry.name, ".masm") or // Microsoft Macro Assembly, ie. SDL_mslibc_x64.masm
                        std.mem.endsWith(u8, entry.name, ".sym") or // Symbol Table
                        std.mem.endsWith(u8, entry.name, ".m4") or // General purpose macro processor (used in most Unix operating systems)
                        std.mem.eql(u8, entry.name, "LICENSE") or // "LICENSE" ignore license files in folders
                        std.mem.eql(u8, entry.name, "Doxyfile") or // "Doxyfile" is for generating documentation from source code
                        // Mac
                        std.mem.endsWith(u8, entry.name, ".podspec") or // CocoaPods (Mac)
                        std.mem.endsWith(u8, entry.name, ".plist") or // Property list format (MacOS,iOS,iPad)
                        // Code generation code
                        std.mem.endsWith(u8, entry.name, ".py") or // Python
                        std.mem.endsWith(u8, entry.name, ".cs") or // C# (C Sharp)
                        std.mem.endsWith(u8, entry.name, ".pl") or // Perl
                        // Git
                        std.mem.eql(u8, entry.name, ".gitignore") or // .gitignore used for Git
                        std.mem.eql(u8, entry.name, ".gitattributes") or // .gitattributes used for Git
                        // HIDAPI
                        std.mem.eql(u8, entry.name, "VERSION") or // "VERSION" used in hidapi folder, contains something like: "0.14.0"
                        std.mem.endsWith(u8, entry.name, ".pp_data") or // Windows test data for hidapi
                        std.mem.endsWith(u8, entry.name, ".rpt_desc") or // Windows test data for hidapi
                        // Batch / Shell / Config scripts
                        std.mem.endsWith(u8, entry.name, ".bat") or // Windows batch
                        std.mem.endsWith(u8, entry.name, ".sh") or // Shell script
                        std.mem.eql(u8, entry.name, "bootstrap") or // "bootstrap" file with no extension, is a shell script
                        std.mem.endsWith(u8, entry.name, ".ac") or // Automated Configuration
                        std.mem.endsWith(u8, entry.name, ".am") or // Makefile.am programmer defined file
                        std.mem.startsWith(u8, entry.name, "Makefile") or // "Makefile", "Makefile.am", "Makefile.freebsd", "Makefile-manual"
                        std.mem.endsWith(u8, entry.name, ".build") or // Meson.build
                        std.mem.endsWith(u8, entry.name, ".cmake.in") or // Cmake config file input
                        std.mem.endsWith(u8, entry.name, ".pc.in") or // Package config file input
                        std.mem.endsWith(u8, entry.name, ".pc") or // Package config file
                        std.mem.endsWith(u8, entry.name, "-hid.rules") or // Udev file for hidapi
                        // Visual Studio (Windows)
                        std.mem.endsWith(u8, entry.name, ".sln") or // Visual Studio solution file
                        std.mem.endsWith(u8, entry.name, ".vcproj") or // Visual C project
                        std.mem.endsWith(u8, entry.name, ".vcxproj") or // Visual C project (XML)
                        // Shaders
                        std.mem.endsWith(u8, entry.name, ".hlsl") or // High level shader language (DirectX shader file)
                        std.mem.endsWith(u8, entry.name, ".hlsli") or //  High level shader language include (DirectX shader file)
                        std.mem.endsWith(u8, entry.name, ".cg") or // Alias of HLSL, CG = C for Graphics
                        std.mem.endsWith(u8, entry.name, ".metal") or // Metal shader
                        std.mem.endsWith(u8, entry.name, ".frag") or // GL fragment shader
                        std.mem.endsWith(u8, entry.name, ".vert") or // GL vertex shader
                        // Text
                        std.mem.endsWith(u8, entry.name, ".txt") or // Text - AUTHORS.txt
                        std.mem.endsWith(u8, entry.name, ".md") or // Markdow - BUILD.autotools.md
                        // Images
                        std.mem.endsWith(u8, entry.name, ".png") // Portable Network Graphics - cmake-gui-drop-down.png
                    ) {
                        // ignore files we definitely don't want explicitly
                        continue;
                    }
                    std.debug.panic("TODO: Unhandled extension for file: {s}", .{entry.name});
                }
            },
            .directory => {
                if (std.mem.eql(u8, entry.name, "test") or // ignore test code
                    std.mem.eql(u8, entry.name, "TestGUI.app.in"))
                {
                    continue;
                }
                const sub_module_name = entry.name;
                var sub_dir: Dir = if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
                    try dir.openDir(g.b.graph.io, entry.name, .{ .iterate = true })
                else
                    try dir.openDir(entry.name, .{ .iterate = true });
                defer if (builtin.zig_version.major == 0 and builtin.zig_version.minor >= 16)
                    sub_dir.close(g.b.graph.io)
                else
                    sub_dir.close();
                const sub_dir_prefix = try std.mem.join(allocator, "/", &.{ dirPrefix, sub_module_name });

                g.dir_depth += 1;
                try g.readAndWriteModule(&subModulerWriter, sub_dir, sub_module_name, sub_dir_prefix);
                g.dir_depth -= 1;
            },
            else => {},
        }
    }

    // If no files, ignore the directory
    const subModulesData = subModulerWriter.buffered();
    if (c_files.items.len == 0 and cpp_files.items.len == 0 and objective_c_files.items.len == 0 and subModulesData.len == 0) {
        return;
    }

    //
    if (moduleName.len > 0) {
        try writer.print("pub const {s} = struct {{\n", .{moduleName});
    }
    if (c_files.items.len > 0) {
        sortStringSliceAlphabetically(c_files.items);
        try writer.writeAll("pub const c_files = [_][]const u8{\n");
        for (c_files.items) |c_file| {
            try writer.print("\"{s}\",\n", .{c_file});
        }
        try writer.writeAll("};\n\n");
    }
    if (cpp_files.items.len > 0) {
        sortStringSliceAlphabetically(cpp_files.items);
        try writer.writeAll("pub const cpp_files = [_][]const u8{\n");
        for (cpp_files.items) |cpp_file| {
            try writer.print("\"{s}\",\n", .{cpp_file});
        }
        try writer.writeAll("};\n\n");
    }
    if (objective_c_files.items.len > 0) {
        sortStringSliceAlphabetically(objective_c_files.items);
        try writer.writeAll("pub const objective_c_files = [_][]const u8{\n");
        for (objective_c_files.items) |objective_c_file| {
            try writer.print("\"{s}\",\n", .{objective_c_file});
        }
        try writer.writeAll("};\n\n");
    }
    if (win32_resource_files.items.len > 0) {
        sortStringSliceAlphabetically(win32_resource_files.items);
        try writer.writeAll("pub const win32_resource_files = [_][]const u8{\n");
        for (win32_resource_files.items) |win32_resource_file| {
            try writer.print("\"{s}\",\n", .{win32_resource_file});
        }
        try writer.writeAll("};\n\n");
    }
    if (subModulesData.len > 0) {
        try writer.writeAll(subModulesData);
    }
    if (moduleName.len > 0) {
        try writer.writeAll("};\n\n");
    }
}

fn stringLessThan(context: void, lhs: []const u8, rhs: []const u8) bool {
    _ = context;
    return std.mem.order(u8, lhs, rhs) == .lt;
}

fn sortStringSliceAlphabetically(slice: [][]const u8) void {
    std.mem.sort([]const u8, slice, {}, stringLessThan);
}

/// Skips to next line or returns null if reached EOF
fn skipToNextLine(data: []u8) ?[]u8 {
    if (std.mem.indexOfScalar(u8, data, '\n')) |i| {
        return data[i + 1 ..];
    }
    return null;
}

/// Used for debug printing the stream
fn getTillNextLine(data: []u8) []u8 {
    if (std.mem.indexOfScalar(u8, data, '\n')) |i| {
        return data[0..i];
    }
    return data;
}

const SdlBuildGenerator = @This();
